# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright 2020 Raritan Inc. All rights reserved.
#
# This is an auto-generated file.

#
# Section generated by IdlC from "LdapServerSettings.idl"
#

import raritan.rpc
from raritan.rpc import Interface, Structure, ValueObject, Enumeration, typecheck, DecodeException

#
# Section generated by IdlC from "RadiusManager.idl"
#

import raritan.rpc
from raritan.rpc import Interface, Structure, ValueObject, Enumeration, typecheck, DecodeException
import raritan.rpc.radius


# interface
class RadiusManager(Interface):
    idlType = "auth.RadiusManager:2.0.0"

    ERR_INVALID_CFG = 1

    ERR_SERVER_UNSPECIFIED = 2

    ERR_INVALID_SHARED_SECRET = 3

    ERR_SERVER_UNREACHABLE = 4

    ERR_AUTHENTICATION_FAILED = 5

    ERR_NO_ROLES = 6

    ERR_NO_KNOWN_ROLES = 7

    class _getRadiusServers(Interface.Method):
        name = 'getRadiusServers'

        @staticmethod
        def encode():
            args = {}
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = [raritan.rpc.radius.ServerSettings.decode(x0, agent) for x0 in rsp['_ret_']]
            for x0 in _ret_:
                typecheck.is_struct(x0, raritan.rpc.radius.ServerSettings, DecodeException)
            return _ret_

    class _setRadiusServers(Interface.Method):
        name = 'setRadiusServers'

        @staticmethod
        def encode(serverList):
            for x0 in serverList:
                typecheck.is_struct(x0, raritan.rpc.radius.ServerSettings, AssertionError)
            args = {}
            args['serverList'] = [raritan.rpc.radius.ServerSettings.encode(x0) for x0 in serverList]
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = rsp['_ret_']
            typecheck.is_int(_ret_, DecodeException)
            return _ret_

    class _testRadiusServer(Interface.Method):
        name = 'testRadiusServer'

        @staticmethod
        def encode(username, password, settings):
            typecheck.is_string(username, AssertionError)
            typecheck.is_string(password, AssertionError)
            typecheck.is_struct(settings, raritan.rpc.radius.ServerSettings, AssertionError)
            args = {}
            args['username'] = username
            args['password'] = password
            args['settings'] = raritan.rpc.radius.ServerSettings.encode(settings)
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = rsp['_ret_']
            typecheck.is_int(_ret_, DecodeException)
            return _ret_
    def __init__(self, target, agent):
        super(RadiusManager, self).__init__(target, agent)
        self.getRadiusServers = RadiusManager._getRadiusServers(self)
        self.setRadiusServers = RadiusManager._setRadiusServers(self)
        self.testRadiusServer = RadiusManager._testRadiusServer(self)

#
# Section generated by IdlC from "AuthManager.idl"
#

import raritan.rpc
from raritan.rpc import Interface, Structure, ValueObject, Enumeration, typecheck, DecodeException
import raritan.rpc.auth


# enumeration
class Type(Enumeration):
    idlType = "auth.Type:1.0.0"
    values = ["LOCAL", "RADIUS", "KERBEROS", "TACACS_PLUS", "LDAP"]

Type.LOCAL = Type(0)
Type.RADIUS = Type(1)
Type.KERBEROS = Type(2)
Type.TACACS_PLUS = Type(3)
Type.LDAP = Type(4)

# structure
class Policy(Structure):
    idlType = "auth.Policy:1.0.0"
    elements = ["type", "useLocalIfRemoteFailed"]

    def __init__(self, type, useLocalIfRemoteFailed):
        typecheck.is_enum(type, raritan.rpc.auth.Type, AssertionError)
        typecheck.is_bool(useLocalIfRemoteFailed, AssertionError)

        self.type = type
        self.useLocalIfRemoteFailed = useLocalIfRemoteFailed

    @classmethod
    def decode(cls, json, agent):
        obj = cls(
            type = raritan.rpc.auth.Type.decode(json['type']),
            useLocalIfRemoteFailed = json['useLocalIfRemoteFailed'],
        )
        return obj

    def encode(self):
        json = {}
        json['type'] = raritan.rpc.auth.Type.encode(self.type)
        json['useLocalIfRemoteFailed'] = self.useLocalIfRemoteFailed
        return json

# interface
class AuthManager(Interface):
    idlType = "auth.AuthManager:1.0.0"

    ERR_UNSUPPORTED_TYPE = 1

    class _getPolicy(Interface.Method):
        name = 'getPolicy'

        @staticmethod
        def encode():
            args = {}
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = raritan.rpc.auth.Policy.decode(rsp['_ret_'], agent)
            typecheck.is_struct(_ret_, raritan.rpc.auth.Policy, DecodeException)
            return _ret_

    class _setPolicy(Interface.Method):
        name = 'setPolicy'

        @staticmethod
        def encode(p):
            typecheck.is_struct(p, raritan.rpc.auth.Policy, AssertionError)
            args = {}
            args['p'] = raritan.rpc.auth.Policy.encode(p)
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = rsp['_ret_']
            typecheck.is_int(_ret_, DecodeException)
            return _ret_
    def __init__(self, target, agent):
        super(AuthManager, self).__init__(target, agent)
        self.getPolicy = AuthManager._getPolicy(self)
        self.setPolicy = AuthManager._setPolicy(self)

#
# Section generated by IdlC from "LdapManager.idl"
#

import raritan.rpc
from raritan.rpc import Interface, Structure, ValueObject, Enumeration, typecheck, DecodeException
import raritan.rpc.auth.ldapsrv


# interface
class LdapManager(Interface):
    idlType = "auth.LdapManager:2.0.0"

    class _getLdapServers(Interface.Method):
        name = 'getLdapServers'

        @staticmethod
        def encode():
            args = {}
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = [raritan.rpc.auth.ldapsrv.ServerSettings.decode(x0, agent) for x0 in rsp['_ret_']]
            for x0 in _ret_:
                typecheck.is_struct(x0, raritan.rpc.auth.ldapsrv.ServerSettings, DecodeException)
            return _ret_

    ERR_CYCLIC_DEP = 1

    ERR_INVALID_CFG = 2

    class _setLdapServers(Interface.Method):
        name = 'setLdapServers'

        @staticmethod
        def encode(serverList):
            for x0 in serverList:
                typecheck.is_struct(x0, raritan.rpc.auth.ldapsrv.ServerSettings, AssertionError)
            args = {}
            args['serverList'] = [raritan.rpc.auth.ldapsrv.ServerSettings.encode(x0) for x0 in serverList]
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = rsp['_ret_']
            typecheck.is_int(_ret_, DecodeException)
            return _ret_

    ERR_SERVER_UNSPECIFIED = 1

    ERR_SERVER_UNREACHABLE = 3

    ERR_AUTHENTICATION_FAILED = 4

    ERR_NO_ROLES = 5

    ERR_NO_KNOWN_ROLES = 6

    class _testLdapServer(Interface.Method):
        name = 'testLdapServer'

        @staticmethod
        def encode(username, password, settings):
            typecheck.is_string(username, AssertionError)
            typecheck.is_string(password, AssertionError)
            typecheck.is_struct(settings, raritan.rpc.auth.ldapsrv.ServerSettings, AssertionError)
            args = {}
            args['username'] = username
            args['password'] = password
            args['settings'] = raritan.rpc.auth.ldapsrv.ServerSettings.encode(settings)
            return args

        @staticmethod
        def decode(rsp, agent):
            _ret_ = rsp['_ret_']
            diagMsg = rsp['diagMsg']
            typecheck.is_int(_ret_, DecodeException)
            typecheck.is_string(diagMsg, DecodeException)
            return (_ret_, diagMsg)
    def __init__(self, target, agent):
        super(LdapManager, self).__init__(target, agent)
        self.getLdapServers = LdapManager._getLdapServers(self)
        self.setLdapServers = LdapManager._setLdapServers(self)
        self.testLdapServer = LdapManager._testLdapServer(self)
